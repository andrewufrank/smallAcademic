<!DOCTYPE HTML>
<html>
<head>
<title>JabRef references</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script type="text/javascript">
<!--
// QuickSearch script for JabRef HTML export 
// Version: 3.0
//
// Copyright (c) 2006-2013, Mark Schenk
//
// This software is distributed under a Creative Commons Attribution 3.0 License
// http://creativecommons.org/licenses/by/3.0/
//
// Features:
// - intuitive find-as-you-type searching
//    ~ case insensitive
//    ~ ignore diacritics (optional)
//
// - search with/without Regular Expressions
// - match BibTeX key
// - put BibTeX type in a data-attribute

// Search settings
var searchAbstract = true;	// search in abstract
var searchReview = true;	// search in review

var noSquiggles = true; 	// ignore diacritics when searching
var searchRegExp = false; 	// enable RegExp searches


if (window.addEventListener) {
	window.addEventListener("load",initSearch,false); }
else if (window.attachEvent) {
	window.attachEvent("onload", initSearch); }

function initSearch() {
	// check for quick search table and searchfield
	if (!document.getElementById('qs_table')||!document.getElementById('quicksearch')) { return; }

	// load all the rows and sort into arrays
	loadTableData();
	
	//find the query field
	qsfield = document.getElementById('qs_field');

	// previous search term; used for speed optimisation
	prevSearch = '';

	//find statistics location
	stats = document.getElementById('stat');
	setStatistics(-1);
	
	// set up preferences
	initPreferences();

	// shows the searchfield
	document.getElementById('quicksearch').style.display = 'block';
	document.getElementById('qs_field').onkeyup = quickSearch;
}

function loadTableData() {
	// find table and appropriate rows
	searchTable = document.getElementById('qs_table');
	var allRows = searchTable.getElementsByTagName('tbody')[0].getElementsByTagName('tr');

	// split all rows into entryRows and infoRows (e.g. abstract, review, bibtex)
	entryRows = new Array(); infoRows = new Array(); absRows = new Array(); revRows = new Array();

	// get data from each row
	entryRowsData = new Array(); absRowsData = new Array(); revRowsData = new Array(); 
	
	BibTeXKeys = new Array();
	RefTypeKeys = new Array();

	for (var i=0, k=0, j=0; i<allRows.length;i++) {
		if (allRows[i].className.match(/entry/)) {
			entryRows[j] = allRows[i];
			entryRowsData[j] = stripDiacritics(getTextContent(allRows[i]));
			allRows[i].id ? BibTeXKeys[j] = allRows[i].id : allRows[i].id = 'autokey_'+j;
			RefTypeKeys[j] = allRows[i].getAttribute('data-reftype');
			j ++;
		} else {
			infoRows[k++] = allRows[i];
			// check for abstract/review
			if (allRows[i].className.match(/abstract/)) {
				absRows.push(allRows[i]);
				absRowsData[j-1] = stripDiacritics(getTextContent(allRows[i]));
			} else if (allRows[i].className.match(/review/)) {
				revRows.push(allRows[i]);
				revRowsData[j-1] = stripDiacritics(getTextContent(allRows[i]));
			}
		}
	}
	//number of entries and rows
	numEntries = entryRows.length;
	numInfo = infoRows.length;
	numAbs = absRows.length;
	numRev = revRows.length;
}

function quickSearch(){
	
	tInput = qsfield;

	if (tInput.value.length == 0) {
		showAll();
		setStatistics(-1);
		qsfield.className = '';
		return;
	} else {
		t = stripDiacritics(tInput.value);

		if(!searchRegExp) { t = escapeRegExp(t); }
			
		// only search for valid RegExp
		try {
			textRegExp = new RegExp(t,"i");
			closeAllInfo();
			qsfield.className = '';
		}
			catch(err) {
			prevSearch = tInput.value;
			qsfield.className = 'invalidsearch';
			return;
		}
	}
	
	// count number of hits
	var hits = 0;

	// start looping through all entry rows
	for (var i = 0; cRow = entryRows[i]; i++){

		// only show search the cells if it isn't already hidden OR if the search term is getting shorter, then search all
		if(cRow.className.indexOf('noshow')==-1 || tInput.value.length <= prevSearch.length){
			var found = false; 

			if (entryRowsData[i].search(textRegExp) != -1 || BibTeXKeys[i].search(textRegExp) != -1 || RefTypeKeys[i].search(textRegExp) != -1){ 
				found = true;
			} else {
				if(searchAbstract && absRowsData[i]!=undefined) {
					if (absRowsData[i].search(textRegExp) != -1){ found=true; } 
				}
				if(searchReview && revRowsData[i]!=undefined) {
					if (revRowsData[i].search(textRegExp) != -1){ found=true; } 
				}
			}
			
			if (found){
				cRow.className = 'entry show';
				hits++;
			} else {
				cRow.className = 'entry noshow';
			}
		}
	}

	// update statistics
	setStatistics(hits)
	
	// set previous search value
	prevSearch = tInput.value;
}


// Strip Diacritics from text
// http://stackoverflow.com/questions/990904/javascript-remove-accents-in-strings

// String containing replacement characters for stripping accents 
var stripstring = 
    'AAAAAAACEEEEIIII'+
    'DNOOOOO.OUUUUY..'+
    'aaaaaaaceeeeiiii'+
    'dnooooo.ouuuuy.y'+
    'AaAaAaCcCcCcCcDd'+
    'DdEeEeEeEeEeGgGg'+
    'GgGgHhHhIiIiIiIi'+
    'IiIiJjKkkLlLlLlL'+
    'lJlNnNnNnnNnOoOo'+
    'OoOoRrRrRrSsSsSs'+
    'SsTtTtTtUuUuUuUu'+
    'UuUuWwYyYZzZzZz.';

function stripDiacritics(str){

    if(noSquiggles==false){
        return str;
    }

    var answer='';
    for(var i=0;i<str.length;i++){
        var ch=str[i];
        var chindex=ch.charCodeAt(0)-192;   // Index of character code in the strip string
        if(chindex>=0 && chindex<stripstring.length){
            // Character is within our table, so we can strip the accent...
            var outch=stripstring.charAt(chindex);
            // ...unless it was shown as a '.'
            if(outch!='.')ch=outch;
        }
        answer+=ch;
    }
    return answer;
}

// http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
// NOTE: must escape every \ in the export code because of the JabRef Export...
function escapeRegExp(str) {
  return str.replace(/[-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

function toggleInfo(articleid,info) {

	var entry = document.getElementById(articleid);
	var abs = document.getElementById('abs_'+articleid);
	var rev = document.getElementById('rev_'+articleid);
	var bib = document.getElementById('bib_'+articleid);
	
	if (abs && info == 'abstract') {
		abs.className.indexOf('noshow') == -1?abs.className = 'abstract noshow':abs.className = 'abstract show';
	} else if (rev && info == 'review') {
		rev.className.indexOf('noshow') == -1?rev.className = 'review noshow':rev.className = 'review show';
	} else if (bib && info == 'bibtex') {
		bib.className.indexOf('noshow') == -1?bib.className = 'bibtex noshow':bib.className = 'bibtex show';
	} else { 
		return;
	}

	// check if one or the other is available
	var revshow; var absshow; var bibshow;
	(abs && abs.className.indexOf('noshow') == -1)? absshow = true: absshow = false;
	(rev && rev.className.indexOf('noshow') == -1)? revshow = true: revshow = false;	
	(bib && bib.className.indexOf('noshow') == -1)? bibshow = true: bibshow = false;
	
	// highlight original entry
	if(entry) {
		if (revshow || absshow || bibshow) {
		entry.className = 'entry highlight show';
		} else {
		entry.className = 'entry show';
		}
	}
	
	// When there's a combination of abstract/review/bibtex showing, need to add class for correct styling
	if(absshow) {
		(revshow||bibshow)?abs.className = 'abstract nextshow':abs.className = 'abstract';
	} 
	if (revshow) {
		bibshow?rev.className = 'review nextshow': rev.className = 'review';
	}	
	
}

function setStatistics (hits) {
	if(hits < 0) { hits=numEntries; }
	if(stats) { stats.firstChild.data = hits + '/' + numEntries}
}

function getTextContent(node) {
	// Function written by Arve Bersvendsen
	// http://www.virtuelvis.com
	
	if (node.nodeType == 3) {
	return node.nodeValue;
	} // text node
	if (node.nodeType == 1 && node.className != "infolinks") { // element node
	var text = [];
	for (var chld = node.firstChild;chld;chld=chld.nextSibling) {
		text.push(getTextContent(chld));
	}
	return text.join("");
	} return ""; // some other node, won't contain text nodes.
}

function showAll(){
	closeAllInfo();
	for (var i = 0; i < numEntries; i++){ entryRows[i].className = 'entry show'; }
}

function closeAllInfo(){
	for (var i=0; i < numInfo; i++){
		if (infoRows[i].className.indexOf('noshow') ==-1) {
			infoRows[i].className = infoRows[i].className + ' noshow';
		}
	}
}

function clearQS() {
	qsfield.value = '';
	showAll();
}

function redoQS(){
	showAll();
	quickSearch(qsfield);
}

function updateSetting(obj){
	var option = obj.id;
	var checked = obj.value;

	switch(option)
	 {
	 case "opt_searchAbs":
	   searchAbstract=!searchAbstract;
	   redoQS();
	   break;
	 case "opt_searchRev":
	   searchReview=!searchReview;
	   redoQS();
	   break;
	 case "opt_useRegExp":
	   searchRegExp=!searchRegExp;
	   redoQS();
	   break;
	 case "opt_noAccents":
	   noSquiggles=!noSquiggles;
	   loadTableData();
	   redoQS();
	   break;
	 }
}

function initPreferences(){
	if(searchAbstract){document.getElementById("opt_searchAbs").checked = true;}
	if(searchReview){document.getElementById("opt_searchRev").checked = true;}
	if(noSquiggles){document.getElementById("opt_noAccents").checked = true;}
	if(searchRegExp){document.getElementById("opt_useRegExp").checked = true;}
	
	if(numAbs==0) {document.getElementById("opt_searchAbs").parentNode.style.display = 'none';}
	if(numRev==0) {document.getElementById("opt_searchRev").parentNode.style.display = 'none';}	
}

function toggleSettings(){
	var togglebutton = document.getElementById('showsettings');
	var settings = document.getElementById('settings');
	
	if(settings.className == "hidden"){
		settings.className = "show";
		togglebutton.innerText = "close settings";
		togglebutton.textContent = "close settings";
	}else{
		settings.className = "hidden";
		togglebutton.innerText = "settings...";		
		togglebutton.textContent = "settings...";
	}
}

-->
</script>
<style type="text/css">
body { background-color: white; font-family: Arial, sans-serif; font-size: 13px; line-height: 1.2; padding: 1em; color: #2E2E2E; width: 50em; margin: auto auto; }

form#quicksearch { width: auto; border-style: solid; border-color: gray; border-width: 1px 0px; padding: 0.7em 0.5em; display:none; position:relative; }
span#searchstat {padding-left: 1em;}

div#settings { margin-top:0.7em; /* border-bottom: 1px transparent solid; background-color: #efefef; border: 1px grey solid; */ }
div#settings ul {margin: 0; padding: 0; }
div#settings li {margin: 0; padding: 0 1em 0 0; display: inline; list-style: none; }
div#settings li + li { border-left: 2px #efefef solid; padding-left: 0.5em;}
div#settings input { margin-bottom: 0px;}

div#settings.hidden {display:none;}

#showsettings { border: 1px grey solid; padding: 0 0.5em; float:right; line-height: 1.6em; text-align: right; }
#showsettings:hover { cursor: pointer; }

.invalidsearch { background-color: red; }
input[type="button"] { background-color: #efefef; border: 1px #2E2E2E solid;}

table { border: 1px gray none; width: 100%; empty-cells: show; border-spacing: 0em 0.1em; margin: 1em 0em; }
th, td { border: none; padding: 0.5em; vertical-align: top; text-align: justify; }

td a { color: navy; text-decoration: none; }
td a:hover  { text-decoration: underline; }

tr.noshow { display: none;}
tr.highlight td { background-color: #EFEFEF; border-top: 2px #2E2E2E solid; font-weight: bold; }
tr.abstract td, tr.review td, tr.bibtex td { background-color: #EFEFEF; text-align: justify; border-bottom: 2px #2E2E2E solid; }
tr.nextshow td { border-bottom-style: none; }

tr.bibtex pre { width: 100%; overflow: auto; white-space: pre-wrap;}
p.infolinks { margin: 0.3em 0em 0em 0em; padding: 0px; }

@media print {
	p.infolinks, #qs_settings, #quicksearch, t.bibtex { display: none !important; }
	tr { page-break-inside: avoid; }
}
</style>
</head>
<body>

<form action="" id="quicksearch">
<input type="text" id="qs_field" autocomplete="off" placeholder="Type to search..." /> <input type="button" onclick="clearQS()" value="clear" />
<span id="searchstat">Matching entries: <span id="stat">0</span></span>
<div id="showsettings" onclick="toggleSettings()">settings...</div>
<div id="settings" class="hidden">
<ul>
<li><input type="checkbox" class="search_setting" id="opt_searchAbs" onchange="updateSetting(this)"><label for="opt_searchAbs"> include abstract</label></li>
<li><input type="checkbox" class="search_setting" id="opt_searchRev" onchange="updateSetting(this)"><label for="opt_searchRev"> include review</label></li>
<li><input type="checkbox" class="search_setting" id="opt_useRegExp" onchange="updateSetting(this)"><label for="opt_useRegExp"> use RegExp</label></li>
<li><input type="checkbox" class="search_setting" id="opt_noAccents" onchange="updateSetting(this)"><label for="opt_noAccents"> ignore accents</label></li>
</ul>
</div>
</form>
<table id="qs_table" border="1">
<tbody>
<tr id="bulbul2010intersection" data-reftype="InCollection" class="entry">
	<td>
Bulbul R and Frank AU (2010), <i>"Intersection of nonconvex polygons using the alternate hierarchical decomposition"</i>, In Geospatial Thinking. , pp. 1-23. Springer.

  <p class="infolinks">
[<a href="javascript:toggleInfo('bulbul2010intersection','abstract')">Abstract</a>]
 [<a href="javascript:toggleInfo('bulbul2010intersection','bibtex')">BibTeX</a>]


[<a href="docs/docs4/4756_Intersection_Nonconvex_Polygons_Using_Alternate_Hierarchical_Decomposition.pdf" target="_blank">PDF</a>]

	</p>
	</td>
</tr>
<tr id="abs_bulbul2010intersection" class="abstract noshow">
	<td><b>Abstract</b>: Intersection computation is one of the fundamental operations of<br>computational geometry. This paper presents an algorithm for intersection<br>computation between two polygons (convex/nonconvex, with nonintersect-<br>ing edges, and with or without holes). The approach is based on the de-<br>composed representation of polygons, alternate hierarchical decomposition<br>(AHD), that decomposes the nonconvex polygon into its convex compo-<br>nents (convex hulls) arranged hierarchically in a tree data structure called<br>convex hull tree (CHT). The overall approach involves three operations (1)<br>intersection between two convex objects (2) intersection between a convex<br>and a CHT (nonconvex object) and, (3) intersection between two CHTs<br>(two nonconvex objects). This gives for (1) the basic operation of intersec-<br>tion computation between two convex hulls, for (2) the CHT traversal with<br>basic operation in (1) and, for (3) the CHT traversal with operation in (2).<br>Only the basic operation of intersection of two convex hulls is geometric<br>(for which well known algorithms exist) and the other operations are re-<br>peated application of this by traversing tree structures.</td>
</tr>


<tr id="bib_bulbul2010intersection" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@incollection{bulbul2010intersection,

  author = {Bulbul, Rizwan and Frank, Andrew U},
  title = {Intersection of nonconvex polygons using the alternate hierarchical decomposition},
  booktitle = {Geospatial Thinking},
  publisher = {Springer},
  year = {2010},
  pages = {1--23},
  file = {docs/docs4/4756_Intersection_Nonconvex_Polygons_Using_Alternate_Hierarchical_Decomposition.pdf}
}
</pre></td>
</tr>
<tr id="Frank2010a" data-reftype="InProceedings" class="entry">
	<td>
Frank AU (2010), <i>"What Is the Use of Ontologies Concerning Organizing Data in Multidisciplinary Projects?"</i>, In Mining in European History Conference. , pp. 9. Universität Innsbruck.

  <p class="infolinks">
[<a href="javascript:toggleInfo('Frank2010a','abstract')">Abstract</a>]
 [<a href="javascript:toggleInfo('Frank2010a','bibtex')">BibTeX</a>]


[<a href="docs/docs4/4861_Himat_2010.pdf" target="_blank">PDF</a>]

	</p>
	</td>
</tr>
<tr id="abs_Frank2010a" class="abstract noshow">
	<td><b>Abstract</b>: A central task of a multidisciplinary projects is to explain and declare the concepts and<br>connections of concepts of all the different disciplines and participants involved. Ontologies<br>and their tools can clarify and interpret the differences between words in context of<br>multidisciplinary users even though in a customary familiar context such words appear to<br>have the same meaning.<br>Ontologies are formal descriptions of concepts that are useful to achieve sharing of<br>computerized files. Ontologies describe things and operations that can be applied to them.<br>They improve communication between people, especially if they communicate indirectly<br>by sharing computerized databases, through organized concepts used to encode the<br>perception of reality in computer representations. The configuration of the central<br>database in which results of disciplines are allocated in a reusable way follows from<br>the formal ontology.<br>The presented tiered ontology distinguishes between simple observations, physical<br>objects that the observer conceptualizes, and the socially constructed objects of social reality.<br>Operations connect between different concepts in a traceable way.<br>A tiered ontology contributes to the separation of observation of physical facts from their<br>interpretation; they are thus important in multi-disciplinary and multi-language research<br>teams. A formal ontology translates to a tool to help the archaeologist to record his<br>observations in a form later reusable and integrable with the results from others!</td>
</tr>


<tr id="bib_Frank2010a" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{Frank2010a,

  author = {Andrew U. Frank},
  title = {What Is the Use of Ontologies Concerning Organizing Data in Multidisciplinary Projects?},
  booktitle = {Mining in European History Conference},
  publisher = {Universität Innsbruck},
  year = {2010},
  pages = {9},
  note = {print approval 12. Mai 2010},
  file = {docs/docs4/4861_Himat_2010.pdf}
}
</pre></td>
</tr>
<tr id="frank4889" data-reftype="Unpublished" class="entry">
	<td>
Frank AU (2010), <i>"Why Context Matters in Giving Driving Instructions ---The Necessity for Representing Decision Points"</i> 

  <p class="infolinks">
[<a href="javascript:toggleInfo('frank4889','abstract')">Abstract</a>]
 [<a href="javascript:toggleInfo('frank4889','bibtex')">BibTeX</a>]


[<a href="docs/docs4/4889_Delmenhorst_10.pdf" target="_blank">PDF</a>]

	</p>
	</td>
</tr>
<tr id="abs_frank4889" class="abstract noshow">
	<td><b>Abstract</b>: A critical review of past research can lead to identify new, fruitful research directions: here I consider<br>the research on driving instruction by linguists and, especially, by Geoinformation scientists, which has<br>concentrated on static spatial situations. The insight obtained from qualitative spatial reasoning is limited<br>because it did not include actions, change, and motion.<br>The important use case for dynamic spatial behavior is navigation: how are instructions communicated<br>to an actor, e.g., from the car navigation system to the driver and how are they acted upon? An analysis<br>of the communication situation must be dynamic; while moving the driver identies decision situations<br>at points where instructions are expected. The participants in way nding communication must have the<br>decision situations as shared context. Maps represent static spatial situations (Kuhn, 2010) and miss the<br>dynamic situations a navigator encounters. Research on recognition of decision situations is recommended<br>to identify decision situatins for the navigation system, which are the context which the navigator assumes<br>to be shared.</td>
</tr>


<tr id="bib_frank4889" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@unpublished{frank4889,

  author = {Andrew U Frank},
  title = {Why Context Matters in Giving Driving Instructions ---The Necessity for Representing Decision Points},
  year = {2010},
  file = {docs/docs4/4889_Delmenhorst_10.pdf}
}
</pre></td>
</tr>
<tr id="frank09quality" data-reftype="InCollection" class="entry">
	<td>
Frank AU (2009), <i>"Why Is Scale an Effective Descriptor for Data Quality? The Physical, Ontological Reasons for Imprecision and Level of Detail"</i>, In Research Trends in Geographic Information Science. , pp. 39-62. Springer Verlag.

  <p class="infolinks">
[<a href="javascript:toggleInfo('frank09quality','abstract')">Abstract</a>]
 [<a href="javascript:toggleInfo('frank09quality','bibtex')">BibTeX</a>]

 [<a href="http://publik.tuwien.ac.at/files/PubDat-176660.pdf" target="_blank">URL</a>]
[<a href="docs/docs4/4713_AF_Scale_Level_Detail_SpringerBook_2009_05.pdf" target="_blank">PDF</a>]

	</p>
	</td>
</tr>
<tr id="abs_frank09quality" class="abstract noshow">
	<td><b>Abstract</b>: Observations and processing of data create data and their quality. Quantita-<br>tive descriptors of data quality must be justified by the properties of the<br>observation process. In this contribution two unavoidable sources of im-<br>perfections in the observation of physical properties are identified and their<br>influences on data collections analyzed. These are, firstly, the random<br>noise disturbing precise measurements; secondly, finiteness of observa-<br>tions—only a finite number of observations is possible and each of it aver-<br>ages properties over an extended area.<br>These two unavoidable imperfections of the data collection process de-<br>termine data quality. Rational data quality measures must be derived from<br>them: Precision is the effect of noise in the measurement. The finiteness of<br>observations leads to a novel formalized and quantifiable approach to level<br>of detail.<br>The customary description of a geographic data set by ‘scale’ seems to<br>relate these two sources of imperfection in a single characteristic; the the-<br>ory described here justifies this approach for static representation of geo-<br>graphic space and shows how to extend it for spatio-temporal data.</td>
</tr>


<tr id="bib_frank09quality" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@incollection{frank09quality,

  author = {Frank, Andrew U.},
  editor = {Navratil, Gerhard},
  title = {Why Is Scale an Effective Descriptor for Data Quality? The Physical, Ontological Reasons for Imprecision and Level of Detail},
  booktitle = {Research Trends in Geographic Information Science},
  publisher = {Springer Verlag},
  year = {2009},
  pages = {39--62},
  url = {http://publik.tuwien.ac.at/files/PubDat-176660.pdf},
  file = {docs/docs4/4713_AF_Scale_Level_Detail_SpringerBook_2009_05.pdf}
}
</pre></td>
</tr>
<tr id="navratil08" data-reftype="InProceedings" class="entry">
	<td>
Navratil G, Karimipour F and Frank AU (2008), <i>"Lifting Imprecise Values"</i>, In The European Information Society Taking Geoinformation Science One Step Further. , pp. 79-94.

  <p class="infolinks">
[<a href="javascript:toggleInfo('navratil08','abstract')">Abstract</a>]
 [<a href="javascript:toggleInfo('navratil08','bibtex')">BibTeX</a>]

 [<a href="http://publik.tuwien.ac.at/files/pub-geo-2321.pdf" target="_blank">URL</a>]
[<a href="docs/docs4/4283_gnfkaf_Lifting_AGILE_08_pub-geo_2321[1].pdf" target="_blank">PDF</a>]

	</p>
	</td>
</tr>
<tr id="abs_navratil08" class="abstract noshow">
	<td><b>Abstract</b>: The article presents a conceptual framework for computations with imprecise values. Typically, the treatment of imprecise values differs from the treatment of precise values. While precise computations use a single number to characterize a value, computations with imprecise values must deal with several numbers for each value. This results in significant changes in the program code because values are represented, e.g., by expectation and standard deviation and both values must be considered within the computations. It would be desirable to have a solution where only limited changes in very specific places of the code are necessary. The mathematical concept of lifting may lead to such a solution.</td>
</tr>


<tr id="bib_navratil08" class="bibtex noshow">
<td><b>BibTeX</b>:
<pre>
@inproceedings{navratil08,

  author = {Navratil, Gerhard and Karimipour, Farid and Frank, Andrew U.},
  editor = {Bernard, Lars and Friis-Christensen, Anders and Pundt, Hardy},
  title = {Lifting Imprecise Values},
  booktitle = {The European Information Society Taking Geoinformation Science One Step Further},
  year = {2008},
  pages = {79--94},
  url = {http://publik.tuwien.ac.at/files/pub-geo-2321.pdf},
  file = {docs/docs4/4283_gnfkaf_Lifting_AGILE_08_pub-geo_2321[1].pdf}
}
</pre></td>
</tr>
</tbody>
</table>
<footer>
 <small>Created by <a href="http://jabref.sourceforge.net">JabRef</a> on 08/01/2019.</small>
</footer>
<!-- file generated by JabRef -->
</body>
</html>
